#!/usr/bin/env python3
"""
training_pipeline.py
--------------------

This module converts JSON animation plans (generated by Gemini via genai_enhancer.py)
into usable training examples for your SLM *and* into executable Manim CE Python scripts
that can be rendered into videos.

Pipeline:
    1. take JSON plan (validated & physics-filled)
    2. convert to deterministic Manim code
    3. optionally render video
    4. package into training examples for SLM

Outputs:
    - outputs/manim_code/<slug>.py
    - outputs/videos/<slug>.mp4
    - outputs/ds_examples/<slug>.jsonl (instruction tuning samples)
"""

import os
import json
import time
import subprocess
import hashlib
from pathlib import Path
from typing import Dict, Any, List

# import physics helpers
from plan_validator import validate_and_fill_plan, projectile_parametric_expr


# ----------------------------
# Output directories
# ----------------------------
MANIM_DIR = Path("outputs/manim_code")
VIDEO_DIR = Path("outputs/videos")
DATASET_DIR = Path("outputs/ds_examples")

for p in (MANIM_DIR, VIDEO_DIR, DATASET_DIR):
    p.mkdir(parents=True, exist_ok=True)


# ----------------------------
# Utilities
# ----------------------------

def slugify(text: str) -> str:
    """Make a filesystem-safe slug with a hash prefix."""
    base = "".join(ch if ch.isalnum() else "_" for ch in text).strip("_")
    h = hashlib.sha1((text + str(time.time())).encode()).hexdigest()[:8]
    return f"{base[:30]}_{h}"


def obj_var(oid: str) -> str:
    """Convert object id to valid Python variable name."""
    return "obj_" + "".join(ch if ch.isalnum() else "_" for ch in oid)


# ----------------------------
# Code Generator — plan → Manim CE code
# ----------------------------

def plan_to_manim_code(plan: Dict[str, Any]) -> str:
    """
    Convert validated animation plan JSON → Manim CE Python script.
    Handles:
        - axes
        - dots
        - circles
        - parametric curves
        - projectile physics scenes

    Returns a full Python script as string.
    """

    title = plan.get("title", "Animation")
    scenes = plan.get("scenes", [])
    class_name = "".join(ch for ch in title.title() if ch.isalnum()) or "GeneratedScene"

    lines: List[str] = []
    lines.append("from manim import *")
    uses_numpy = any(
        "projectile" in (s.get("hint", "").lower()) or
        any(obj.get("type") == "ParametricFunction" for obj in s.get("objects", []))
        for s in scenes
    )
    if uses_numpy:
        lines.append("import numpy as np")

    lines.append("")
    lines.append(f"class {class_name}(Scene):")
    lines.append("    def construct(self):")

    # Iterate through scenes
    for scene in scenes:

        # Create objects first
        for obj in scene.get("objects", []):
            oid = obj.get("id", "object")
            otype = obj.get("type", "Dot")
            params = obj.get("params", {})
            var = obj_var(oid)

            if otype == "Axes":
                xr = params.get("x_range", [0, 10])
                yr = params.get("y_range", [0, 5])
                lines.append(f"        {var} = Axes(x_range={xr}, y_range={yr})")
                lines.append(f"        self.play(Create({var}), run_time=0.6)")

            elif otype == "Dot":
                color = repr(params.get("color", "YELLOW"))
                lines.append(f"        {var} = Dot(color={color})")

            elif otype == "Circle":
                radius = params.get("radius", 0.5)
                lines.append(f"        {var} = Circle(radius={radius})")

            elif otype == "ParametricFunction":
                expr = params.get("expr", "lambda t: np.array([t,0,0])")
                t_range = params.get("t_range", [0, 1])
                lines.append(f"        {var} = ParametricFunction({expr}, t_range={t_range})")

            elif otype == "Text":
                text = repr(params.get("text", ""))
                lines.append(f"        {var} = Text({text})")

            else:
                # Unknown: fallback dot
                lines.append(f"        {var} = Dot(color='WHITE')")

        # Handle projectile physics scene
        hint = (scene.get("hint") or "").lower()
        if any(k in hint for k in ("projectile", "trajectory", "parabolic")):
            phys = scene.get("params", {}).get("physics", {})
            v0 = float(phys.get("v0", 12.0))
            angle = float(phys.get("angle_degrees", 45.0))
            g = float(phys.get("g", 9.81))

            expr, t_end = projectile_parametric_expr(v0, angle, g)
            ball_var = obj_var(f"ball_{scene.get('id','ball')}")
            lines.append(f"        {ball_var} = Dot(color=YELLOW)")
            lines.append(f"        {ball_var}_path = ParametricFunction({expr}, t_range=[0,{t_end:.4f}])")
            lines.append(f"        self.play(FadeIn({ball_var}))")
            lines.append(f"        self.play(MoveAlongPath({ball_var}, {ball_var}_path), run_time={t_end:.4f})")
            lines.append("        self.wait(0.4)")
            continue  # Skip generic actions

        # Generic actions
        for act in scene.get("actions", []):
            atype = act.get("type")
            target = act.get("target")
            var_target = obj_var(target) if target else None
            params = act.get("params", {})
            dur = params.get("duration", params.get("run_time", 1.0))

            if atype == "FadeIn" and var_target:
                lines.append(f"        self.play(FadeIn({var_target}), run_time={dur})")

            elif atype == "FadeOut" and var_target:
                lines.append(f"        self.play(FadeOut({var_target}), run_time={dur})")

            elif atype == "Create" and var_target:
                lines.append(f"        self.play(Create({var_target}), run_time={dur})")

            elif atype == "MoveAlongPath":
                path_expr = params.get("path")
                if path_expr and var_target:
                    pvar = var_target + "_path"
                    lines.append(f"        {pvar} = {path_expr}")
                    lines.append(f"        self.play(MoveAlongPath({var_target}, {pvar}), run_time={dur})")
                else:
                    lines.append(f"        self.wait({dur})")

            else:
                # fallback
                lines.append(f"        self.wait({dur})")

    # end construct()
    lines.append("        self.wait()")

    return "\n".join(lines)


# ----------------------------
# Training Example Builder
# ----------------------------

def plan_to_example(plan: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convert plan JSON into the JSONL entry:
        instruction: convert this plan into Manim code
        input: plan
        output: generated code
    """
    manim_script = plan_to_manim_code(plan)
    return {
        "instruction": "Convert the scene-plan JSON into Manim CE Python code.",
        "input": plan,
        "output": manim_script,
    }


# ----------------------------
# Manim Video Renderer
# ----------------------------

def render_manim_script(script: str, class_name: str, slug: str) -> Path:
    """
    Save script to file and run Manim CLI to render video.
    """
    py_path = MANIM_DIR / f"{slug}.py"
    py_path.write_text(script, encoding="utf-8")

    video_out = VIDEO_DIR / f"{slug}.mp4"

    cmd = [
        "manim",
        "-qk",                 # medium quality
        "-o", video_out.name,  # output filename
        py_path,               # python file
        class_name,
    ]

    print(f"[INFO] Rendering with: {' '.join(map(str, cmd))}")
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as err:
        print("[ERROR] Manim rendering failed:", err)

    return video_out


# ----------------------------
# Pipeline Entry Point
# ----------------------------

def process_plan(plan: Dict[str, Any], render: bool = True) -> Dict[str, Any]:
    """
    Full pipeline:
        - validate plan
        - convert to Manim code
        - optionally render video
        - generate dataset example
    """

    validated, diag = validate_and_fill_plan(plan)

    # Build Manim script
    script = plan_to_manim_code(validated)
    title = validated.get("title", "Animation")
    class_name = "".join(ch for ch in title.title() if ch.isalnum()) or "GeneratedScene"
    slug = slugify(title)

    # Save script
    py_file = MANIM_DIR / f"{slug}.py"
    py_file.write_text(script, encoding="utf-8")

    # Render video
    video_path = None
    if render:
        video_path = render_manim_script(script, class_name, slug)

    # Build training dataset example
    example = plan_to_example(validated)
    ds_path = DATASET_DIR / f"{slug}.jsonl"
    ds_path.write_text(json.dumps(example, ensure_ascii=False) + "\n", encoding="utf-8")

    return {
        "slug": slug,
        "manim_file": str(py_file),
        "video_file": str(video_path) if video_path else None,
        "dataset_entry": str(ds_path),
        "diagnostics": diag,
    }


# CLI for local testing
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("plan_json_path", help="Path to the scene plan JSON file")
    parser.add_argument("--no-render", action="store_true")
    args = parser.parse_args()

    plan = json.load(open(args.plan_json_path, "r", encoding="utf-8"))
    result = process_plan(plan, render=not args.no_render)

    print(json.dumps(result, indent=2))
